# Http/Https

## 1.Http请求行包括哪些部分？

- 请求方法类型
- 请求路径
- 协议版本

## 2.Http有哪些常用的请求首部？
| 首部字段名 | 说明 |
| :--: | :--: |
| Accept | 用户代理可处理的媒体类型 |
| Accept-Charset | 优先的字符集 |
| Accept-Encoding | 优先的内容编码 |
| Accept-Language | 优先的语言（自然语言） |
| Authorization | Web 认证信息 |
| Expect | 期待服务器的特定行为 |
| From | 用户的电子邮箱地址 |
| Host | 请求资源所在服务器 |
| If-Match | 比较实体标记（ETag） |
| If-Modified-Since | 比较资源的更新时间 |
| If-None-Match | 比较实体标记（与 If-Match 相反） |
| If-Range | 资源未更新时发送实体 Byte 的范围请求 |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards | 最大传输逐跳数 |
| Proxy-Authorization | 代理服务器要求客户端的认证信息 |
| Range | 实体的字节范围请求 |
| Referer | 对请求中 URI 的原始获取方 |
| TE | 传输编码的优先级 |
| User-Agent | HTTP 客户端程序的信息 |

## 3.Http有哪些常用的响应首部
| 首部字段名 | 说明 |
| :--: | :--: |
| Allow | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言 |
| Content-Length | 实体主体的大小 |
| Content-Location | 替代对应资源的 URI |
| Content-MD5 | 实体主体的报文摘要 |
| Content-Range | 实体主体的位置范围 |
| Content-Type | 实体主体的媒体类型 |
| Expires | 实体主体过期的日期时间 |
| Last-Modified | 资源的最后修改日期时间 |
## 4.Http的常用请求方法有哪些？

| 请求方法 | 功能     |
| :------: | -------- |
|   GET    | 获取数据 |
|   POST   | 修改数据 |
|   PUT    | 增加数据 |
|  DELETE  | 删除数据 |

## 5.GET和POST有什么区别？

### 5.1 缓存

GET是可以缓存的，但POST不行。同时也需要响应报文的Cache-Control支持

### 5.2 请求参数

GET的请求参数是在url上的，而POST不用。因此在参数的安全性上POST优于GET；同时GET的参数长度是有限制的，但POST没有。

### 5.3 安全性

GET是获取数据，因此对于服务端数据来说是安全的；POST修改对于服务端数据是不安全的。

### 5.4 幂等性

同5.3一样，GET多次请求返回的结果一致。因此具备幂等性；POST则不具有幂等性

## 6. Http常见的响应码有哪些？

| 状态码 | 类别 | 含义 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |
### 6.1 响应码1xx
-  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
### 6.2 响应码2xx
-  **200 OK** 
-  **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
-  **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。
### 6.3 响应码3xx
-  **301 Moved Permanently** ：永久性重定向

-  **302 Found** ：临时性重定向

-  **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。

-  **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。

-  **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。
### 6.4 响应码4xx

-  **400 Bad Request** ：请求报文中存在语法错误。

-  **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

-  **403 Forbidden** ：请求被拒绝。

-  **404 Not Found** 

### 6.4 响应码5xx

-  **500 Internal Server Error** ：服务器正在执行请求时发生错误。
-  **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 7. Http1.1新增哪些功能

### 7.1 长连接

Http1.1之前，客户端每请求一个数据都会和服务建立一次TCP连接，这样的通信效率很低。长连接是指只需建立一次连接，就能进行多次Http通信。

- Http1.1以前默认是短连接，需要长连接要设置Connection首部为Connection:Keep-Alived
- Http1.1及之后是默认长连接。

### 7.2 支持设置缓存max-age

### 7.3 支持虚拟主机

一台物理机多台虚拟主机

## 8. Http2.0有哪些特点？

### 8.1 首部压缩

在HTTP1.x时代，首部的传输会占据大量的网络流量，在Http2.0时代，客户端和服务端都会维护一个已经见过的首部字段表，这样避免了首部字段的重复传输。

同时还会利用哈夫曼编码对首部进行压缩，减少网络流量的消耗

![](D:\github.plasticlove.com\docs\blog\pics\_u4E0B_u8F7D.png)

### 8.2 双向数据流

在Http2.0时代，客户端和服务端的概念和划分不在显得那么重要，也就是说客户端也可以是服务端，反过来也一样。在通信过程中，只会有一个TCP连接的存在。这个连接承载着双向通信的数据流(Stream)

每个Stream有其唯一标识

Http2.0时代传输数据被抽象为消息(message)，每个Message又包括首部消息和数据消息。

消息由帧表示，帧是数据传输的最小单位。帧之间可以错位传输，也就是说Http2.0可以设置请求/响应的优先级，

根据的帧的标识最后封装成一个完整的消息。

![](D:\github.plasticlove.com\docs\blog\pics\e3f1657c-80fc-4dfa-9643-bf51abd201c6.png)

## 9. Https相比Http有哪些优点？

在HTTP时代，数据都是明文传输的，这样数据的安全性就没有保障。而https就主要体现在安全性上。可以认为Https是Http+SSL(Security Socket Layer)的组合。通过Http先和SSL通信，之后SSL再与TCP通信。这样Https就具有了三个特点：

- 加密(防窃听)
- 认证(防伪装)
- 完整性保护(防篡改)

### 9.1 对数据明文加密传输

#### 9.1.1 对称加密

对称加密是指加密和解密使用的是同一把密钥，如用123加密就用123解密。

优点：传输效率高

缺点：无法安全的将密钥发送给对方

![](D:\github.plasticlove.com\docs\blog\pics\7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png)

#### 9.1.2 非对称加密

非对称加密指的就是加密和解密使用的不是同一把密钥。发送方利用接收方发送的公开密钥对数据进行加密，接收方利用其私有密钥对数据解密。可以认为公开密钥和私有密钥成对关系。

这里就会有一个问题：公开密钥书都可以获得，如果另一个发送方采用同样的公开密钥发送消息，接收方依然会做出响应。这里就涉及到9.2的身份认证问题。

![](D:\github.plasticlove.com\docs\blog\pics\39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png)

#### 9.1.3 Https采用的加密方式

https采用的是对称加密和非对称加密的混合加密方式。

首先利用非对称加密加密用于传输的对称密钥确保密钥传输的安全性；之后利用对称加密完成发送和接收方的数据加密传输。(下图中的Session Key就是对称密钥)

![](D:\github.plasticlove.com\docs\blog\pics\How-HTTPS-Works.png)

### 9.2 对通信双方进行身份认证

认证主要是为了确认对方身份，防止第三方伪装成发送方发送数据。Https的认证主要是通过证书来完成的。

数字证书认证机构(CA)是客户端和服务端都认证的第三方证书发给机构

#### 9.2.1 数字签名

假设通信双方是A和B。

A是服务端：

A首先利用hash函数，将data进行hash，得到数字摘要；

A在利用自己私钥对数字摘要进行加密的到数字签名；

将数字签名放在data后一起发送给B。

B是客户端：

B接收到的数据为data+数字签名，数字签名 = encrypt(hash(data));

B利用公钥(可以认为是服务端A下发的，与A的私钥配对)解密接收到的数字签名得到h1 = hash(data)；

B再将接收到的data用与A相同的hash函数进行hash运算得到h2;

比较h1和h2的值，若一样说明认证成功。

这里会有两个问题：

1. 如何保证数字签名不被更改？
2. 如何确保B的公钥是A的私钥对应的公钥？如果C偷偷将B的公钥换成自己私钥配对的，这是C就可以冒充A发送数据给B。

第一个问题：因为数字签名是A的私钥加密的，没有私钥，无法更改。

第二个问题：公钥的信任这时

就要用到数字证书。

#### 9.2.2 数字证书

数字证书是建立在数字签名基础上的。

首先A会去权威的证书认证机构(CA)申请证书，CA会将A的相关信息和A的公钥进行加密，然后和数字签名以及data放在一起，发送给B。

B也通过CA的公钥对证书进行解密，获得数字签名并与接收到数字签名作比较，如果一致就说明认证成功

### 9.3 检验内容的完整性

Http提供报文摘要确保完整性，但是由于可以修改报文并重新生成MD5，导致并不安全。

Https利用加密和认证，确保报文摘要的安全性。