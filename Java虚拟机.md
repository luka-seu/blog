## 1. JVM内存模型
以下是JVM运行时的数据分区(摘自CS-Notes)
<div align="center"> <img src="pics/5778d113-8e13-4c53-b5bf-801e58080b97.png" width="400px"> </div><br>
JVM内存模型主要可以分为：
- 程序计数器
- 本地方法栈
- 虚拟机栈
- 虚拟机堆
- 方法区

### 1.1 程序计数器
程序计数器是记录虚拟机正在执行的字节码指令的地址
### 1.2 本地方法栈
本地方法栈主要是用来为本地方法服务的，比如一些用C或者C++编写的本地方法。
### 1.3 虚拟机栈
- java中每个方法的执行对应着一次方法入栈和弹栈的过程。这里的栈指的就是虚拟机栈。每个方法会在栈中会创建属于自己的栈帧，在栈帧中会存放方法的本地变量，以及对常量池的引用。
- 当过多的方法入栈，而栈的深度无法满足时，就会抛出StackOverFlowError。最典型的就是递归
- 栈的大小会动态扩展，当栈无法申请到内存空间时，就会抛出OuOfMemeryError。对于虚拟机每一个部分，如果申请不到内存，都会抛出这个异常。
### 1.4 虚拟机堆
堆就是存放新建对象的地方。也是GC的主要区域。堆内存主要分为新生代和老年代。主要是因为现代垃圾收集器主要都是分代收集，年轻代采用复制算法，老年代采用标记-整理算法。
<div align="center"> <img src="pics/4cf711a8-7ab2-4152-b85c-d5c226733807.png" width="600"/> </div><br>
### 1.5 方法区
方法区主要存放常量，静态变量。方法区里有一很重要的区域叫运行时常量池，主要用于存放一些字面量和符号引用(比如String字符串字面量)。
## 2. JVM垃圾收集机制
### 2.1 判断哪些对象需要回收
#### 2.1.1 引用计数法
引用计数法是指，对每一个对象都有一个计数器，当对象被引用一次，计数器会加一；如果计算器归零，说明对象不再被引用，因此需要被垃圾收集器回收。
**一个令其无法使用的缺点：**
无法解决循环引用问题。如果A引用了B，B也引用了A，则计数器永远无法归零。就无法回收。

```java
public class Test {
    public Object instance = null;
    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}
```
#### 2.1.2 可达性分析法
通过GC Roots开始遍历，可以通过引用链到达的对象时可达的，无法到达的对象时不可达的，可以认为没有被使用，需要回收。
**哪些对象可以当作GC Roots：**
- 方法中局部变量引用的对象；
- 常量引用的对象；
- 静态变量引用的对象
- JNI 方法中引用的变量
<div align="center"> <img src="pics/83d909d2-3858-4fe1-8ff4-16471db0b180.png" width="350px"> </div><br>
### 2.2 引用类型
#### 2.2.1 强引用
平常通过new创建的对象引用都是强引用，强引用引用的对象不会GC回收
#### 2.2.2 软引用
软引用引用的对象会在内存不足的时候被GC回收
#### 2.2.3 弱引用
弱引用引用的对象只会存活到下次GC时
#### 2.2.4 虚引用
虚引用没有实际意义，只会告知当前对象是否已经被垃圾回收。
### 2.3 回收算法
#### 2.3.1 标记-清除
标记清除是指先标记活动的对象，清除阶段将未标记的待回收对象回收。
- 标记和清除阶段的效率都不高
- 易产生大量的内存碎片
<div align="center"> <img src="pics/005b481b-502b-4e3f-985d-d043c2b330aa.png" width="400px"> </div><br>
#### 2.3.2 标记整理
标记阶段和标记清除一致，然后让存活对象向同一侧移动，之后清理掉边界以外的内存
- 优点：避免了内存碎片化
- 缺点：移动大量对象，效率很低
<div align="center"> <img src="pics/ccd773a5-ad38-4022-895c-7ac318f31437.png" width="400px"> </div><br>
#### 2.3.3 复制算法
首先将内存分为两块，每次回收时将存活对象从一块移动到另一块，然后直接清理原先那块内存。
- 优点：效率高
- 缺点：相当于只能使用一半的内存区域
<div align="center"> <img src="pics/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" width="400px"> </div><br>
#### 2.3.4 分代收集
现在主流的java虚拟机都是分代收集，针对年轻代和年老代采用不同的垃圾回收算法。
- 年轻代：复制算法
  - 年轻代复制算法内存分配的区域并不是55开，而是分为Eden(伊甸园)和Surivior两个区域；内存大小比例为8:1，这样就解决了复制算法的内存利用率低的问题。当垃圾回收后存活的对象超过10%时，意味着surivior区域放不下，这时就会将对象放入年老代。而这个过程年老代就需要进行内存分配担保，这个之后详解。
- 年老代：标记整理
- 由于年老代对象大多是存活时间较长，而且需要回收的对象较少，因此使用标记整理。
### 2.4 垃圾收集器
## 3.内存分配机制和回收策略
### 3.1 Minor GC和Full GC
### 3.2 内存分配机制
### 3.3 Full GC条件
## 4. JVM类加载机制
### 4.1 类加载过程
### 4.2 类加载器
### 4.3 双亲委派模型
