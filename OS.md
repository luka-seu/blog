# 计算机操作系统
## 1. 操作系统特征有哪些?
### 1.1 并发
并发是指在同一时间段内可以支持多个程序同时运行；并行指的是同一时刻多个指令同时执行。
并发需要多核处理器的支持；而进程和线程的确立，使得并行成为可能。
### 1.2 共享
共享指的是各个程序之间共享资源，其中包括同步共享和互斥共享。
- 互斥共享：临界资源，如打印机
- 同步共享：同步手段，同步访问
### 1.3 异步
异步指的是程序并不是规定先执行那一部分，后执行那一部分，而是同时随机执行，最后走到终点。
### 1.4 虚拟
虚拟指的是把一个物理实体转换为一个逻辑实体。
在操作系统中，主要通过时分复用和空分复用完成虚拟。

- 时分复用：CPU的抢占式调度，不同时间片执行不同指令。
- 空分复用：物理内存-->逻辑内存地址空间。每个程序有自己的地址空间，地址空间的页被映射到物理内存，并不需要每块地址空间页都要有对应的物理内存映射，当内存中的页没有被映射到物理内存时，通过页面置换算法，置换其他的页。
## 2. 操作系统的功能有哪些？
### 2.1 进程管理
### 2.2 内存管理
### 2.3 文件管理
### 2.4 设备管理
## 3. 操作系统的进程管理
进程管理包括进程调度，进程同步，进程通信，死锁处理等.
### 3.1 进程和线程
- 进程是资源分配的基本单位；线程是执行调度的基本单位。进程之间相互独立，一个进程可以包括多个线程；
- 线程不拥有资源，可以访问隶属于进程的资源。同一个进程内的线程切换不会导致进程切换，进程间的线程切换回导致进程切换；
- 进程间切换资源消耗要远远大于线程间切换，同时，创建进程的资源消耗也大于创建线程；
- 线程间可以依赖于进程的共享区域进行通信，但是进程间同时依赖于IPC。
### 3.2 进程的状态转换
进程的状态：新建，就绪，运行，阻塞，销毁。

新建—>就绪—>运行—>阻塞
![](./assets/ProcessState.png)

- 首先只有就绪和运行两个状态之间可以相互切换。当进程(线程)获取CPU时间片，就会由就绪状态到运行状态。当时间片用完后，会变回就绪状态等待下一个时间片的获得；在java中调用yield()方法也会变回就绪状态。
- 新建到就绪状态在java中是thread.start();
- 运行状态到阻塞状态的在java中有wait()，join()，sleep()等。
- wait()，join()，yield()三个方法都会释放锁，但sleep()不会。join()是让调用线程先执行完毕；yield()方法和sleep()方法类似，但是不能指定多长时间自动唤醒，只能等待下次调度。
### 3.3 进程的调度算法
#### 3.3.1 FCFS
先来先服务--非抢占式
#### 3.3.2 最短进程优先(SPN)
以处理进程需要的最短时间为优--非抢占式
#### 3.3.3 最短剩余时间(SRT)
动态跟踪最短剩余时间--抢占式
#### 3.3.4 Round-Robin 
时间片轮询
### 3.4 进程间的同步
进程间的同步主要是指让不同进程安装一定顺序执行
#### 3.4.1 临界区
临界区是指同一时间只允许一个进程访问的区域。用来控制进程对公共资源的顺序访问。
优点：速度快，简单；
缺点：只能同步本进程内的线程，进程间的线程无法同步
#### 3.4.2 互斥量
互斥量相当于一把锁，只有获取互斥量的线程才能对资源进行访问。
优点：可以跨进程同步
缺点：创建互斥量的资源消耗大
#### 3.4.3 信号量
信号量是控制同一时刻访问资源的最大线程数，可以认为互斥量是信号量=1的特殊情况。
优点：适用于socket通信
缺点：复杂
#### 3.4.4 事件
通过事件通知之后的线程执行。
优点：跨进程同步

[进程间同步方式](https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78591330)
### 3.5 进程间的通信方式
- 进程间通信和同步的区别：
通信是不同进程分享数据；
同步是保证多个进程按照一定次序执行
#### 3.5.1 管道
- 管道一般是指无名管道。一般只能用到父子进程和兄弟进程；
- 管道是半双工的通信方式，也就是支持同一时间只能一发一收的双向通信。
#### 3.5.2 FIFO
也称为命名管道，可以用于任何进程(因为管道有命名)
#### 3.5.3 信号量
信号量一般搭配共享内存使用，用于控制同一时刻有多少线程同时访问共享资源。可以通过设置信号量的值，从而控制对共享资源的访问
#### 3.5.4 共享内存
是最快的进程间通信方式，因为直接操作内存
#### 3.5.5 socket
不同主机的进程之间的通信


## 4. 操作系统的内存管理
## 5. 死锁

### 5.1 死锁的形成条件
#### 5.1.1 互斥条件
多个线程对同一个互斥资源的争夺构成死锁的一个条件。一旦一个线程抢到，其他线程就无法获得。
#### 5.1.2 请求和保持条件
指的是当一个线程占有一个资源，但是有需要其他资源，在未获得其他资源的时候不释放自身资源。
#### 5.1.3 资源不剥夺条件
一个线程不能去主动剥夺其他线程未释放的资源
#### 5.1.4 环路等待条件
A等待B释放资源，B等待A释放资源。形成环路等待