# Redis
## 1. redis 概述
redis是一款基于内存的key-value型的NoSql数据库，与关系型数据库不同的是，其基于key-value的形式存储。同时由于其基于内存，因此其IO速度远高于一般关系型数据库，官方宣称可以达到10wQPS。同时redis也支持数据的持久化和丰富的数据结构，因此redis在诸多环境中获得应用。
## 2. redis 持久化方案
redis与其他key-value数据库很大的不同点之一，就是其支持数据的持久化。这样，在关机之后，内存的数据也会保留在磁盘中。redis支持两种持久化方案：RDB和AOF。
### 2.1 RDB
RDB是redis每隔一个指定的时间持久化一次，这个时间可以自己配置。主要机制就是fork出一个子进程，每隔一定时间将内存中数据写到次磁盘中。
#### 2.1.1 RDB优点
1. 每隔一定是时间生成一份数据快照，这样以多个文件备份不同时间段的数据，非常适合做冷备份；
2. 对于redis正常的读写IO影响较小，以为redis只是fork一个子进程，让其完成和磁盘的IO
3. 非常适合数据恢复，只需要将rdb文件加载到内存即可。
#### 2.1.2 RDB缺点
1. RDB的缺点也很明显，因为是每隔一段时间备份一次，因此在这个时间间隔内，如果宕机，就会丢失这一时间段数据；
2. 当每次需要备份的数据较大时，对客户端提供服务可能会阻塞较长时间。因此，考虑性能，RDB备份方式的间隔时间不宜太长。
### 2.2 AOF
AOF是每次将对redis的写操作写入到日志文件中，并且是以append的方式写入，这样在重启的时候，直接回溯AOF的日志文件恢复数据即可。
#### 2.2.1 AOF优点
1. 相较于RDB方式，AOF的数据安全性更好。AOF一般每隔一秒，就会有后台进程执行一次fsync操作。也就是强制将OS Cache中的数据刷新到磁盘上。这样，及时宕机，丢失的数据也不会超过一秒；
2. 由于是append方式的写入日志，这样在一些误操作性的灾难恢复中，AOF或许会更有效。比如，误执行了一次flush db的操作，这时只需找到AOF日志文件，将最后一条指令删除即可；
3. AOF由于是append方式写日志，因此不用内存寻址。
4. 文件重写：每隔一段时间将redis中数据以命令的方式写到新的AOF日志文件中，不会去改变旧文件。这样可以去除一些过期命令和无效命令；同时也可以将多条命令合并。达到压缩文件的目的。
#### 2.2.2 AOF缺点
1. 首先是AOF的文件普遍比RDB文件大很多；
2. AOF持久化随着不通的的策略，会对正常redis的IO产生较大的影响。
   - no：不持久化，就不谈了。
   - everysec：每秒同步一次。正常环境的配置，每秒钟向磁盘刷新一次数据。QPS可以很高，同时数据的安全性也可以得到保障。
   - always：每次只要有写命令，就同步一次。对redis的IO有较大影响。同时也会减少磁盘寿命。
3. 在数据恢复上不如RDB方式，每次redis重启都需要回溯和执行日志中的命令。开销较大
## 3. redis 数据结构
redis得到广泛应用的很重要的原因之一就是其丰富的数据结构，redis总共支持五种数据结构:
- string
- hash
- list
- set
- zset
这五种数据结构为redis的应用提供了大量的支持
### 3.1 string
redis的string数据结构相当于java的字符串，不过其采用的方式是存储的结构类似于java中Arraylist，也就是会有一个初始的容量存储字符，当容量超过一定阈值的时候，就会动态扩容。
### 3.2 hash
redis的hash结构相当于java中的HashMap，采用数组加链表的方式存储数据，当产生hash冲突的时候，通过链表法将新加入的元素插入链表的头部。不同是，hash表扩容需要rehash的时候，redis的hash结构做了优化，HashMap的rehash过程是个相当消耗资源的过程。在redis中，rehash是一个渐进式的rehash过程，其并不是一次性rehash结束，而是旧表和rehash之后的新表一起使用，等到rehash结束后，在将旧表的空间删除。
### 3.3 list
redis的list结构是列表结构，相当于java中的LinkedList，意味着在其插入速度较快，但是查询较慢。但是redis的list是一种quicklist。首先是其采用连续的地址空间存储一部分数据，因为传统链表维护寻址指针的地址空间消耗比较大。这一部分数据就会形成一个ziplist，这样多个ziplist合起来就形成一个quicklist。
### 3.4 set
redis的set相当于java中的HashSet，主要特征就在于存储的元素不会重复。
### 3.5 zset
redis的zset是排序集合，大概相当于java中的TreeSet，其排序所依赖的数据结构是一种叫做skiplist的跳跃列表。跳跃列表的机制就在于其采用分层的结构存储数据，则每次查询的术后就不必去编列整个链表。只需分层的遍历即可。

[跳跃链表及其JAVA实现](https://blog.csdn.net/qpzkobe/article/details/80056807)

## 4 redis的应用场景
redis的特性决定着redis有着很丰富的应用场景。总结起来，redis主要用于三个场景:
- 缓存
- 分布式锁
- 消息队列
### 4.1 缓存
redis最常用的场景就是缓存。redis由于其基于内存的特性，使得其存储数据很快。在业务层和DB之间增加一个缓存模块，会使得整个系统的QPS改善很多。在redis用作缓存的时候，主要是要注意一下几个问题。
#### 4.1.1 redis的key的过期策略
- allkeys-random：在所有key中随机删除key
- allkeys-lru：在所有key中删除最近最少使用的
- volatile-random：在设置过期时间的key中随机删除key
- volatile-lru：在设置过期时间的key中删除最近最少使用的
- volatile-ttl：在设置过期时间的key中删除最早到期的
#### 4.1.2 redis的key的删除时间
当redis的key需要删除时，redis主要提供一下两种key的删除方案:
- 主动删除：redis会定时清理过期的数据
- 被动删除：过期的key只有被使用到的时候才会被清理
#### 4.1.3 redis的缓存一致性解决方案
主要有三种解决方案：
- Cache Aside：这也是最常规的缓存设计模式，也就是在查询缓存时，如果命中缓存，直接返回；没有命中就去数据库查，查到返回并写入缓存。更新缓存时，先更新数据库，再让缓存失效。

  这里有几个问题

  - 是先操作缓存还是操作数据库？

    应该是先操作数据库，在操作缓存。因为如果A线程更新操作，B线程更新操作。如果先操作缓存，A线程先更新缓存，在去写数据库，还没有写如数据库，这是B线程更新了缓存，同时B线程写入数据库成功，这时缓存中保存的时B线程的数据，然后A再去写入数据库，数据库保存的是A线程的数据。这样会导致数据库和缓存中的数据不一致的问题。

  - 是更新缓存还是直接让缓存失效？

    应该是让缓存失效，因为如果是更新缓存大量额外的操作的话，不如直接删除缓存

- Read/Write through

- Write Back

  异步更新数据库，但只能保证最终一致性。
### 4.2 分布式锁
分布式锁主要用来解决现在系统分布式部署的问题，保证在同一时刻只有一个线程操作资源，再单击环境下java api可以解决，但是在分布式环境下，就需要借助于分布式锁。
redis实现分布式锁的方案：
主要利用set(lockKey, threadId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime)命令。

### 4.3 消息队列
